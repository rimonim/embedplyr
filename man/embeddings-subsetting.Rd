% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/embeddings-subsetting.R
\name{[.embeddings}
\alias{[.embeddings}
\alias{[<-.embeddings}
\alias{subset.embeddings}
\title{Extract or Subset Parts of Embeddings Objects}
\usage{
\method{[}{embeddings}(x, i, j, drop = TRUE)

\method{[}{embeddings}(x, i, j) <- value

\method{subset}{embeddings}(x, subset, ...)
}
\arguments{
\item{x}{object to be subsetted.}

\item{i}{row index or indices to extract or replace. Can be \code{numeric} or \code{character}.}

\item{j}{column index or indeces to extract or replace. Can be \code{numeric} or \code{character}.}

\item{drop}{logical. If \code{TRUE} (the default) and the result is one-dimensional
(e.g. a single row), the output will be a (named) vector.}

\item{value}{typically a numeric vector, matrix, or embeddings object.}

\item{subset}{logical expression indicating elements or rows to keep:
    missing values are taken as false.}

\item{...}{further arguments to be passed to or from other methods.}
}
\description{
Extraction, replacement, and subsetting nearly identically matches the behavior
of matrices, with one exception: If a character item in \code{i} matches multiple
rownames in \code{x}, the \emph{last} match will be returned.
}
\details{
The difference between \code{embeddings[i,]} and \code{\link[=emb]{emb(embeddings, i)}} is that
the former will throw an error when items of \code{i} are not valid indices, whereas
the latter will handle it gracefully (at the cost of a few more milliseconds
if \code{i} is long).
}
\examples{
glove_twitter_25d["this",]
glove_twitter_25d[c("this", "that"),]

glove_twitter_25d[1,]
glove_twitter_25d[1:10,]

glove_twitter_25d[1]
glove_twitter_25d[1,1:10]

duplicate_tokens <- embeddings(
  1:15,
  nrow = 3,
  dimnames = list(c("this", "that", "this"))
  )
duplicate_tokens["this",]
}
